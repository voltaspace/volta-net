package gateway

import (
	"Volta/Config"
	"Volta/Core/Container"
	"Volta/Core/gateway/wspl"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"reflect"
	"runtime/debug"
	"strconv"
	"strings"
	"time"
)

type Switch struct {

}

//.开启内部交换服务
func (netswitch Switch) Handle(){
	fmt.Println("SwitchWorker Start")
	tcpAddr, err := net.ResolveTCPAddr("tcp4", Config.Server.SwitchAddr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error: %s", err.Error())
		os.Exit(1)
	}
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error: %s", err.Error())
		os.Exit(1)
	}
	defer listener.Close()
	for {
		conn, err := listener.Accept()
		if err != nil {
			return
		}
		go netswitch.handle(conn)
	}
}

func (netswitch Switch) handle(conn net.Conn){
	defer netswitch.endStack(conn) // close connection before exit
	conn.SetReadDeadline(time.Now().Add(10 * time.Second))
	buf := make([]byte, 128000) // set maxium wspl length to 12800B to prevent flood attack
	for{
		readLen, err := conn.Read(buf)
		if err != nil {
			fmt.Println(err)
			break
		}
		if readLen == 0 {
			break // connection already closed by client
		} else if strings.TrimSpace(string(buf[:readLen])) == "timestamp" {
			break
		} else {
			var data wspl.Protocol
			err := json.Unmarshal([]byte(buf[:readLen]), &data)
			if err != nil {
				break
			}
			netswitch.switchControl(data,conn)
			break
		}
	}
	return
}

//.消息控制器
func (netswitch Switch) switchControl(data wspl.Protocol,conn net.Conn){
	relay,err := Container.App.Make(strconv.FormatInt(int64(data.Cmd),10))
	if err != nil {
		conn.Write([]byte("no protocal"))
		return
	}
	//.创建relay对象
	//refV := reflect.New(relay.ConType)
	//method := refV.MethodByName(relay.Method)

	method := relay.ConValue.MethodByName(relay.Method)
	if !method.IsValid() {
		return
	}
	paramList := make([]reflect.Value,2)
	paramList[0] = reflect.ValueOf(data)
	paramList[1] = reflect.ValueOf(conn)
	//paramList := []reflect.Value{
	//	reflect.ValueOf(data),
	//	reflect.ValueOf(conn),
	//}
	//.初始化relay属性
	//relayInterface := refV.Interface().(Relays.NetApp)
	//relayInterface.SetNetConn(conn)
	method.Call(paramList)
	//conn.Write([]byte(value[0].Interface().(string)))
}

func (netswitch Switch) endStack(conn net.Conn){
	if err := recover(); err != nil {
		//将客户端的这次请求头、主体等信息+程序的堆栈信息
		msg := map[string]interface{}{
			"error":   err,                   //真正的错误信息
			"wspl": conn,   				  //连接句柄信息
			"stack":   string(debug.Stack()), //此刻程序的堆栈信息
		}
		fmt.Println(msg)
	}
	conn.Close()
}